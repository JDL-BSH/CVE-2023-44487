import csv
import socket
import httpx
import argparse
from h2.connection import H2Connection
from h2.config import H2Configuration
from urllib.parse import urlparse
from datetime import datetime
import requests


def get_source_ips():
    """
    Retrieve the internal and external IP addresses of the machine.
    
    Returns:
        tuple: (internal_ip, external_ip)
    """
    try:
        # Get external IP address
        response = requests.get('http://ifconfig.me', timeout=5)  # 5-second timeout for external IP
        external_ip = response.text.strip()

        # Get internal IP address
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.settimeout(2)  # 2-second timeout for internal IP
        try:
            # Doesn't even have to be reachable; the OS just uses this to determine the most appropriate network interface to use
            s.connect(('8.8.8.8', 1))
            internal_ip = s.getsockname()[0]
        except socket.timeout:
            internal_ip = '127.0.0.1'
        except Exception as e:
            internal_ip = '127.0.0.1'
        finally:
            s.close()
        
        return internal_ip, external_ip
    except requests.exceptions.Timeout:
        print("External IP request timed out.")
        return None, None
    except Exception as e:
        print(f"Error: {e}")
        return None, None

    
def check_http2_support(url):
    """
    Check if the given URL supports HTTP/2.
    
    Parameters:
        url (str): The URL to check.
        
    Returns:
        tuple: (status, error/version)
        status: 1 if HTTP/2 is supported, 0 otherwise, -1 on error.
        error/version: Error message or HTTP version if not HTTP/2.
    """
    try:
        with httpx.Client(http2=True) as client:
            response = client.get(url)
        
        if response.http_version == 'HTTP/2':
            return (1, "")
        else:
            return (0, f"{response.http_version}")
            
    except Exception as e:
        return (-1, f"{e}")

def send_rst_stream_h2(host, port, stream_id, uri_path='/'):
    """
    Send an RST_STREAM frame to the given host and port.
    
    Parameters:
        host (str): The hostname.
        port (int): The port number.
        stream_id (int): The stream ID to reset.
        uri_path (str): The URI path for the GET request.
        
    Returns:
        int: 1 if successful, -1 otherwise.
    """
    try:
        # Create a socket connection
        sock = socket.create_connection((host, port))
        config = H2Configuration(client_side=True)
        conn = H2Connection(config=config)
        
        # Initiate HTTP/2 connection
        conn.initiate_connection()
        sock.sendall(conn.data_to_send())
        
        # Send GET request headers
        headers = [(':method', 'GET'), (':authority', host), (':scheme', 'https'), (':path', uri_path)]
        conn.send_headers(stream_id, headers)
        sock.sendall(conn.data_to_send())
        
        # Listen for frames and send RST_STREAM when appropriate
        while True:
            data = sock.recv(65535)
            if not data:
                break

            events = conn.receive_data(data)
            for event in events:
                if event.stream_id == stream_id:
                    conn.reset_stream(event.stream_id)
                    sock.sendall(conn.data_to_send())
                    return (1, "")

        sock.close()
        return (0, "No response")
    except Exception as e:
        return (-1, f"{e}")

def extract_hostname_port_uri(url):
    """
    Extract the hostname, port, and URI from a URL.
    
    Parameters:
        url (str): The URL to extract from.
        
    Returns:
        tuple: (hostname, port, uri)
    """
    try:
        parsed_url = urlparse(url)
        hostname = parsed_url.hostname
        port = parsed_url.port
        scheme = parsed_url.scheme
        uri = parsed_url.path  # Extracting the URI
        if uri == "":
            uri = "/"

        if not hostname:
            return -1, -1, ""

        if port:
            return hostname, port, uri

        if scheme == 'http':
            return hostname, 80, uri

        if scheme == 'https':
            return hostname, 443, uri

        return hostname, (80, 443), uri
    except Exception as e:
        return -1, -1, ""

if __name__ == "__main__":

    # Get source IPs
    internal_ip, external_ip = get_source_ips()
    
    # Parse arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('-i', '--input', required=True)
    parser.add_argument('-o', '--output', required=True)
    args = parser.parse_args()

    with open(args.input) as infile, open(args.output, 'w', newline='') as outfile:
        csv_writer = csv.writer(outfile)
        
        # Write header row
        csv_writer.writerow(['Timestamp', 'Source Internal IP', 'Source External IP', 'URL', 'Vulnerability Status', 'Error/Downgrade Version'])
        
        for line in infile:
            addr = line.strip()
            if addr != "":

                # Get current timestamp
                now = datetime.now().strftime("%Y-%m-%d %H:%M:%S") 

                print(f"Checking {addr}...")
                
                # Check HTTP/2 support
                http2support, err = check_http2_support(addr)
                
                # Extract hostname and port 
                hostname, port, uri = extract_hostname_port_uri(addr)
                
                if http2support == 1:
                    resp, err2 = send_rst_stream_h2(hostname, port, 1, uri)
                    if resp == 1:
                        csv_writer.writerow([now, internal_ip, external_ip, addr, 'VULNERABLE', ''])
                    elif resp == -1:
                        csv_writer.writerow([now, internal_ip, external_ip, addr, 'POSSIBLE', f'Failed to send RST_STREAM: {err2}'])
                    elif resp == 0:
                        csv_writer.writerow([now, internal_ip, external_ip, addr, 'LIKELY', 'Got no response from RST_STREAM request and socket closed'])
                else:
                    if http2support == 0:
                        csv_writer.writerow([now, internal_ip, external_ip, addr, 'SAFE', f"Downgraded to {err}"]) 
                    else:
                        csv_writer.writerow([now, internal_ip, external_ip, addr, 'ERROR', err])
